# 無登入交易系統架構設計

> **專案需求**：完全信任、大型規模（>1000人/月）、純展示貨幣、免費額度
>
> **最後更新**：2025-10-25

---

## 目錄

1. [技術棧選擇](#技術棧選擇)
2. [資料庫設計](#資料庫設計)
3. [API 架構](#api-架構)
4. [Rate Limiting 策略](#rate-limiting-策略)
5. [前端實作](#前端實作)
6. [成本優化與監控](#成本優化與監控)
7. [安全措施](#安全措施)
8. [實作階段規劃](#實作階段規劃)
9. [免費額度評估](#免費額度評估)

---

## 技術棧選擇

### 核心技術

```yaml
前端框架: Next.js 15 + App Router
資料庫: Supabase (PostgreSQL)
  - Row Level Security (匿名訪問)
  - Real-time subscriptions (可選)
  - 免費額度: 500MB 資料庫 + 50K 月活躍用戶

Rate Limiting:
  - 方案一: Vercel Edge Middleware + 內存計數（簡單場景）
  - 方案二: Upstash Redis（推薦，免費額度：10K 命令/天）

狀態管理:
  - React Context (輕量)
  - Zustand (可選，用於複雜狀態)

部署平台:
  - Vercel (免費額度: 100GB 流量)
```

### 依賴套件

```bash
# 必須安裝
npm install @supabase/supabase-js

# Rate Limiting (擇一)
npm install @upstash/redis  # 推薦
# 或使用內建的 Vercel Edge Middleware

# 狀態管理 (可選)
npm install zustand
```

---

## 資料庫設計

### 核心表結構

#### 1. 訪問令牌表 (access_tokens)

```sql
CREATE TABLE access_tokens (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  character_id TEXT NOT NULL,          -- 角色 ID（用戶輸入）
  token TEXT UNIQUE NOT NULL,          -- 訪問令牌
  fingerprint TEXT,                    -- 瀏覽器指紋（防濫用）
  last_active_at TIMESTAMPTZ DEFAULT NOW(),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 索引優化
CREATE INDEX idx_token ON access_tokens(token);
CREATE INDEX idx_character_id ON access_tokens(character_id);
CREATE INDEX idx_last_active ON access_tokens(last_active_at);
```

**說明**：
- `token`: 唯一訪問令牌，用於識別用戶
- `fingerprint`: 瀏覽器指紋，防止單一用戶創建過多令牌
- `last_active_at`: 用於清理不活躍令牌

---

#### 2. 物品庫存表 (items)

```sql
CREATE TABLE items (
  id BIGSERIAL PRIMARY KEY,            -- 使用 BIGSERIAL 支援大量資料
  character_id TEXT NOT NULL,          -- 擁有者角色 ID
  item_id INT NOT NULL,                -- 遊戲物品 ID（參考本地資料）
  quantity SMALLINT DEFAULT 1,         -- 數量
  status SMALLINT DEFAULT 0,           -- 0=庫存, 1=上架中, 2=交易中
  price BIGINT,                        -- 售價（楓幣）
  listed_at TIMESTAMPTZ,               -- 上架時間
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 索引優化（關鍵！避免全表掃描）
CREATE INDEX idx_status ON items(status) WHERE status = 1;  -- 部分索引
CREATE INDEX idx_character ON items(character_id);
CREATE INDEX idx_item_id ON items(item_id) WHERE status = 1;
CREATE INDEX idx_price ON items(price) WHERE status = 1;
```

**索引策略說明**：
- **部分索引** (`WHERE status = 1`)：只索引上架中的物品，大幅減少索引大小
- **複合查詢優化**：支援按物品 ID、價格範圍快速查詢

---

#### 3. 交易記錄表 (trades)

```sql
CREATE TABLE trades (
  id BIGSERIAL PRIMARY KEY,
  item_id BIGINT REFERENCES items(id) ON DELETE SET NULL,
  seller_id TEXT NOT NULL,             -- 賣家角色 ID
  buyer_id TEXT NOT NULL,              -- 買家角色 ID
  price BIGINT NOT NULL,
  traded_at TIMESTAMPTZ DEFAULT NOW()
);

-- 索引優化
CREATE INDEX idx_seller ON trades(seller_id, traded_at DESC);
CREATE INDEX idx_buyer ON trades(buyer_id, traded_at DESC);
CREATE INDEX idx_traded_at ON trades(traded_at DESC);
```

**說明**：
- 使用 `ON DELETE SET NULL` 避免刪除物品時交易記錄丟失
- 複合索引支援「我的交易歷史」快速查詢

---

#### 4. Rate Limit 記錄表 (rate_limits)

```sql
-- 僅在不使用 Redis 時需要
CREATE TABLE rate_limits (
  id BIGSERIAL PRIMARY KEY,
  identifier TEXT NOT NULL,            -- IP 或 token
  action TEXT NOT NULL,                -- 操作類型 (login, purchase, list)
  count SMALLINT DEFAULT 1,
  window_start TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_lookup ON rate_limits(identifier, action, window_start);
```

---

### 資料庫函數與清理策略

#### 定期清理函數（節省空間）

```sql
-- 1. 刪除 30 天前的舊交易記錄
CREATE OR REPLACE FUNCTION cleanup_old_trades()
RETURNS void AS $$
BEGIN
  DELETE FROM trades WHERE traded_at < NOW() - INTERVAL '30 days';
END;
$$ LANGUAGE plpgsql;

-- 2. 清理過期的訪問令牌（超過 7 天未活動）
CREATE OR REPLACE FUNCTION cleanup_inactive_tokens()
RETURNS void AS $$
BEGIN
  DELETE FROM access_tokens WHERE last_active_at < NOW() - INTERVAL '7 days';
END;
$$ LANGUAGE plpgsql;

-- 3. 清理過期的 rate limit 記錄
CREATE OR REPLACE FUNCTION cleanup_rate_limits()
RETURNS void AS $$
BEGIN
  DELETE FROM rate_limits WHERE window_start < NOW() - INTERVAL '1 hour';
END;
$$ LANGUAGE plpgsql;
```

---

#### 購買物品存儲過程（確保交易原子性）

```sql
CREATE OR REPLACE FUNCTION purchase_item(
  p_item_id BIGINT,
  p_buyer_id TEXT
)
RETURNS TABLE(trade_id BIGINT, seller_id TEXT, price BIGINT) AS $$
DECLARE
  v_seller_id TEXT;
  v_price BIGINT;
  v_trade_id BIGINT;
BEGIN
  -- 鎖定物品行（防止並發購買）
  SELECT character_id, price INTO v_seller_id, v_price
  FROM items
  WHERE id = p_item_id AND status = 1
  FOR UPDATE;

  -- 檢查物品是否存在且上架中
  IF NOT FOUND THEN
    RAISE EXCEPTION '物品不存在或已下架';
  END IF;

  -- 檢查是否自己購買自己的物品
  IF v_seller_id = p_buyer_id THEN
    RAISE EXCEPTION '不能購買自己的物品';
  END IF;

  -- 更新物品狀態（轉移所有權）
  UPDATE items
  SET status = 0, character_id = p_buyer_id
  WHERE id = p_item_id;

  -- 記錄交易
  INSERT INTO trades (item_id, seller_id, buyer_id, price)
  VALUES (p_item_id, v_seller_id, p_buyer_id, v_price)
  RETURNING id INTO v_trade_id;

  RETURN QUERY SELECT v_trade_id, v_seller_id, v_price;
END;
$$ LANGUAGE plpgsql;
```

**關鍵設計**：
- 使用 `FOR UPDATE` 行級鎖防止並發購買
- 完整的業務邏輯驗證
- 原子性操作確保資料一致性

---

## API 架構

### 目錄結構

```
src/
├── app/
│   ├── api/
│   │   ├── auth/
│   │   │   └── token/route.ts          # 獲取訪問令牌
│   │   ├── items/
│   │   │   ├── route.ts                 # GET: 查詢物品, POST: 新增物品
│   │   │   ├── [id]/route.ts           # PUT: 修改, DELETE: 刪除
│   │   │   └── list/route.ts           # POST: 上架物品
│   │   ├── market/
│   │   │   ├── route.ts                 # GET: 市場列表（上架中的物品）
│   │   │   └── search/route.ts         # GET: 搜尋/篩選
│   │   ├── trades/
│   │   │   ├── route.ts                 # POST: 購買物品
│   │   │   ├── history/route.ts        # GET: 交易歷史
│   │   │   └── exchange/route.ts       # POST: 物品交換
│   │   └── maintenance/
│   │       ├── cleanup/route.ts        # 定期清理（Cron Job）
│   │       └── stats/route.ts          # 用量統計
│   └── trade/
│       └── page.tsx                     # 交易系統主頁面
├── lib/
│   ├── supabase/
│   │   ├── client.ts                    # 客戶端 Supabase 實例
│   │   ├── server.ts                    # 服務端 Supabase 實例
│   │   └── types.ts                     # 資料庫類型定義
│   ├── middleware/
│   │   ├── rate-limit.ts                # Rate Limiting 中間件
│   │   └── auth.ts                      # 令牌驗證中間件
│   ├── services/
│   │   ├── item.service.ts              # 物品服務
│   │   ├── trade.service.ts             # 交易服務
│   │   └── auth.service.ts              # 認證服務
│   └── utils/
│       ├── fingerprint.ts               # 瀏覽器指紋生成
│       └── token.ts                     # 令牌生成工具
└── components/
    └── trade/
        ├── MarketList.tsx               # 市場列表
        ├── MyItems.tsx                  # 我的物品
        ├── TradeHistory.tsx             # 交易歷史
        └── ItemCard.tsx                 # 物品卡片組件
```

---

### 核心 API 實作

#### 1. 認證 API

**檔案**: `src/app/api/auth/token/route.ts`

```typescript
import { NextRequest } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { generateToken } from '@/lib/utils/token'
import { generateFingerprint } from '@/lib/utils/fingerprint'

export async function POST(request: NextRequest) {
  try {
    const { characterId } = await request.json()

    // 輸入驗證
    if (!characterId || typeof characterId !== 'string') {
      return Response.json(
        { error: '角色 ID 格式錯誤' },
        { status: 400 }
      )
    }

    // Rate Limiting: 每個 IP 每小時最多 10 次請求
    // ... (rate limit logic)

    const fingerprint = generateFingerprint(request)
    const token = generateToken()
    const supabase = createClient()

    // 存入資料庫
    const { data, error } = await supabase
      .from('access_tokens')
      .insert({
        character_id: characterId,
        token,
        fingerprint
      })
      .select()
      .single()

    if (error) {
      return Response.json(
        { error: '創建令牌失敗' },
        { status: 500 }
      )
    }

    return Response.json({
      token: data.token,
      characterId: data.character_id
    })
  } catch (error) {
    return Response.json(
      { error: '伺服器錯誤' },
      { status: 500 }
    )
  }
}
```

---

#### 2. 市場列表 API

**檔案**: `src/app/api/market/route.ts`

```typescript
import { NextRequest } from 'next/server'
import { createClient } from '@/lib/supabase/server'

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const page = parseInt(searchParams.get('page') || '1')
    const limit = Math.min(parseInt(searchParams.get('limit') || '20'), 100)
    const itemId = searchParams.get('itemId')
    const minPrice = searchParams.get('minPrice')
    const maxPrice = searchParams.get('maxPrice')

    const supabase = createClient()
    let query = supabase
      .from('items')
      .select('*', { count: 'exact' })
      .eq('status', 1)  // 只查詢上架中的物品
      .order('listed_at', { ascending: false })
      .range((page - 1) * limit, page * limit - 1)

    // 動態篩選
    if (itemId) query = query.eq('item_id', parseInt(itemId))
    if (minPrice) query = query.gte('price', parseInt(minPrice))
    if (maxPrice) query = query.lte('price', parseInt(maxPrice))

    const { data, error, count } = await query

    if (error) {
      return Response.json(
        { error: '查詢失敗' },
        { status: 500 }
      )
    }

    return Response.json({
      items: data,
      pagination: {
        page,
        limit,
        total: count,
        totalPages: Math.ceil((count || 0) / limit)
      }
    })
  } catch (error) {
    return Response.json(
      { error: '伺服器錯誤' },
      { status: 500 }
    )
  }
}
```

---

#### 3. 購買物品 API

**檔案**: `src/app/api/trades/route.ts`

```typescript
import { NextRequest } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { verifyToken } from '@/lib/middleware/auth'

export async function POST(request: NextRequest) {
  try {
    // 驗證 token
    const token = request.headers.get('Authorization')?.replace('Bearer ', '')
    const { characterId } = await verifyToken(token)

    const { itemId } = await request.json()

    if (!itemId) {
      return Response.json(
        { error: '物品 ID 必填' },
        { status: 400 }
      )
    }

    const supabase = createClient()

    // 調用存儲過程（確保原子性）
    const { data, error } = await supabase.rpc('purchase_item', {
      p_item_id: itemId,
      p_buyer_id: characterId
    })

    if (error) {
      return Response.json(
        { error: error.message },
        { status: 400 }
      )
    }

    return Response.json({
      success: true,
      trade: data
    })
  } catch (error) {
    return Response.json(
      { error: error instanceof Error ? error.message : '購買失敗' },
      { status: 500 }
    )
  }
}
```

---

#### 4. 我的物品 API

**檔案**: `src/app/api/items/route.ts`

```typescript
import { NextRequest } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { verifyToken } from '@/lib/middleware/auth'

// 獲取我的物品
export async function GET(request: NextRequest) {
  try {
    const token = request.headers.get('Authorization')?.replace('Bearer ', '')
    const { characterId } = await verifyToken(token)

    const supabase = createClient()
    const { data, error } = await supabase
      .from('items')
      .select('*')
      .eq('character_id', characterId)
      .order('created_at', { ascending: false })

    if (error) throw error

    return Response.json({ items: data })
  } catch (error) {
    return Response.json(
      { error: '查詢失敗' },
      { status: 500 }
    )
  }
}

// 新增物品
export async function POST(request: NextRequest) {
  try {
    const token = request.headers.get('Authorization')?.replace('Bearer ', '')
    const { characterId } = await verifyToken(token)

    const { itemId, quantity } = await request.json()

    const supabase = createClient()
    const { data, error } = await supabase
      .from('items')
      .insert({
        character_id: characterId,
        item_id: itemId,
        quantity: quantity || 1,
        status: 0
      })
      .select()
      .single()

    if (error) throw error

    return Response.json({ item: data })
  } catch (error) {
    return Response.json(
      { error: '新增失敗' },
      { status: 500 }
    )
  }
}
```

---

#### 5. 上架物品 API

**檔案**: `src/app/api/items/list/route.ts`

```typescript
import { NextRequest } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { verifyToken } from '@/lib/middleware/auth'

export async function POST(request: NextRequest) {
  try {
    const token = request.headers.get('Authorization')?.replace('Bearer ', '')
    const { characterId } = await verifyToken(token)

    const { itemId, price } = await request.json()

    if (!price || price <= 0) {
      return Response.json(
        { error: '價格必須大於 0' },
        { status: 400 }
      )
    }

    const supabase = createClient()

    // 確認物品屬於該角色且未上架
    const { data: item, error: fetchError } = await supabase
      .from('items')
      .select('*')
      .eq('id', itemId)
      .eq('character_id', characterId)
      .eq('status', 0)
      .single()

    if (fetchError || !item) {
      return Response.json(
        { error: '物品不存在或已上架' },
        { status: 404 }
      )
    }

    // 更新狀態為上架
    const { data, error } = await supabase
      .from('items')
      .update({
        status: 1,
        price,
        listed_at: new Date().toISOString()
      })
      .eq('id', itemId)
      .select()
      .single()

    if (error) throw error

    return Response.json({ item: data })
  } catch (error) {
    return Response.json(
      { error: '上架失敗' },
      { status: 500 }
    )
  }
}
```

---

## Rate Limiting 策略

### 方案一：Vercel Edge Middleware（簡單版）

**檔案**: `src/middleware.ts`

```typescript
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

const rateLimit = new Map<string, { count: number; resetAt: number }>()

export function middleware(request: NextRequest) {
  if (!request.nextUrl.pathname.startsWith('/api/')) {
    return NextResponse.next()
  }

  const ip = request.ip || request.headers.get('x-forwarded-for') || 'unknown'
  const now = Date.now()

  // 每分鐘限制 60 次請求
  const limit = 60
  const window = 60 * 1000

  const record = rateLimit.get(ip)

  if (record && record.resetAt > now) {
    if (record.count >= limit) {
      return NextResponse.json(
        { error: '請求過於頻繁，請稍後再試' },
        { status: 429 }
      )
    }
    record.count++
  } else {
    rateLimit.set(ip, { count: 1, resetAt: now + window })
  }

  // 清理過期記錄（防止內存洩漏）
  if (rateLimit.size > 10000) {
    for (const [key, value] of rateLimit.entries()) {
      if (value.resetAt <= now) {
        rateLimit.delete(key)
      }
    }
  }

  return NextResponse.next()
}

export const config = {
  matcher: '/api/:path*'
}
```

**優點**：
- 無需外部依賴
- 簡單易實作

**缺點**：
- 多個 Edge Function 實例無法共享狀態
- 記憶體限制較嚴格

---

### 方案二：Upstash Redis（推薦）

**檔案**: `src/lib/middleware/rate-limit.ts`

```typescript
import { Redis } from '@upstash/redis'

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!
})

export async function rateLimit(
  identifier: string,
  limit: number = 60,
  window: number = 60
): Promise<{ success: boolean; remaining: number }> {
  const key = `rate_limit:${identifier}`
  const now = Date.now()

  // 使用 Redis 的滑動窗口算法
  const multi = redis.multi()
  multi.zadd(key, { score: now, member: `${now}` })
  multi.zremrangebyscore(key, 0, now - window * 1000)
  multi.zcard(key)
  multi.expire(key, window)

  const results = await multi.exec()
  const count = results[2] as number

  return {
    success: count <= limit,
    remaining: Math.max(0, limit - count)
  }
}
```

**使用範例**：

```typescript
// 在 API Route 中使用
import { rateLimit } from '@/lib/middleware/rate-limit'

export async function POST(request: NextRequest) {
  const ip = request.ip || 'unknown'
  const { success, remaining } = await rateLimit(ip, 10, 60) // 每分鐘 10 次

  if (!success) {
    return Response.json(
      { error: '請求過於頻繁' },
      { status: 429, headers: { 'X-RateLimit-Remaining': remaining.toString() } }
    )
  }

  // ... 正常處理請求
}
```

**優點**：
- 分散式環境下可靠
- 免費額度充足（10K 命令/天）
- 精確的滑動窗口算法

---

### Rate Limit 配置建議

| 操作類型 | 限制 | 時間窗口 | 說明 |
|---------|------|---------|------|
| 獲取令牌 | 10 次 | 1 小時 | 防止大量創建令牌 |
| 購買物品 | 20 次 | 1 分鐘 | 防止惡意刷單 |
| 上架物品 | 30 次 | 1 分鐘 | 防止垃圾物品 |
| 查詢市場 | 60 次 | 1 分鐘 | 一般查詢限制 |
| 交易歷史 | 30 次 | 1 分鐘 | 降低資料庫負擔 |

---

## 前端實作

### 1. 認證 Context

**檔案**: `src/contexts/TradeAuthContext.tsx`

```typescript
'use client'

import { createContext, useContext, useState, useEffect, ReactNode } from 'react'

interface TradeAuthContextType {
  token: string | null
  characterId: string | null
  login: (characterId: string) => Promise<void>
  logout: () => void
  isAuthenticated: boolean
}

const TradeAuthContext = createContext<TradeAuthContextType | undefined>(undefined)

export function TradeAuthProvider({ children }: { children: ReactNode }) {
  const [token, setToken] = useState<string | null>(null)
  const [characterId, setCharacterId] = useState<string | null>(null)

  useEffect(() => {
    // 從 localStorage 恢復 token
    const saved = localStorage.getItem('trade_auth')
    if (saved) {
      try {
        const { token, characterId } = JSON.parse(saved)
        setToken(token)
        setCharacterId(characterId)
      } catch {
        localStorage.removeItem('trade_auth')
      }
    }
  }, [])

  const login = async (characterId: string) => {
    const res = await fetch('/api/auth/token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ characterId })
    })

    if (!res.ok) {
      const error = await res.json()
      throw new Error(error.error || '登入失敗')
    }

    const data = await res.json()
    setToken(data.token)
    setCharacterId(data.characterId)

    localStorage.setItem('trade_auth', JSON.stringify(data))
  }

  const logout = () => {
    setToken(null)
    setCharacterId(null)
    localStorage.removeItem('trade_auth')
  }

  return (
    <TradeAuthContext.Provider value={{
      token,
      characterId,
      login,
      logout,
      isAuthenticated: !!token
    }}>
      {children}
    </TradeAuthContext.Provider>
  )
}

export const useTradeAuth = () => {
  const context = useContext(TradeAuthContext)
  if (!context) {
    throw new Error('useTradeAuth must be used within TradeAuthProvider')
  }
  return context
}
```

---

### 2. 市場列表組件

**檔案**: `src/components/trade/MarketList.tsx`

```typescript
'use client'

import { useState, useEffect } from 'react'
import { useTradeAuth } from '@/contexts/TradeAuthContext'

interface MarketItem {
  id: number
  item_id: number
  character_id: string
  price: number
  quantity: number
  listed_at: string
}

export function MarketList() {
  const [items, setItems] = useState<MarketItem[]>([])
  const [loading, setLoading] = useState(true)
  const [page, setPage] = useState(1)
  const { token } = useTradeAuth()

  useEffect(() => {
    fetchMarketItems()
  }, [page])

  const fetchMarketItems = async () => {
    setLoading(true)
    try {
      const res = await fetch(`/api/market?page=${page}&limit=20`)
      const data = await res.json()
      setItems(data.items)
    } catch (error) {
      console.error('獲取市場列表失敗', error)
    } finally {
      setLoading(false)
    }
  }

  const handlePurchase = async (itemId: number) => {
    if (!token) {
      alert('請先登入')
      return
    }

    try {
      const res = await fetch('/api/trades', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({ itemId })
      })

      if (!res.ok) {
        const error = await res.json()
        throw new Error(error.error)
      }

      alert('購買成功！')
      fetchMarketItems()
    } catch (error) {
      alert(error instanceof Error ? error.message : '購買失敗')
    }
  }

  if (loading) return <div>載入中...</div>

  return (
    <div className="space-y-4">
      <h2 className="text-2xl font-bold">交易市場</h2>

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {items.map(item => (
          <div key={item.id} className="border rounded p-4">
            <div>物品 ID: {item.item_id}</div>
            <div>數量: {item.quantity}</div>
            <div>價格: {item.price.toLocaleString()} 楓幣</div>
            <div className="text-sm text-gray-500">
              賣家: {item.character_id}
            </div>
            <button
              onClick={() => handlePurchase(item.id)}
              className="mt-2 bg-blue-500 text-white px-4 py-2 rounded"
            >
              購買
            </button>
          </div>
        ))}
      </div>

      <div className="flex gap-2 justify-center">
        <button
          onClick={() => setPage(p => Math.max(1, p - 1))}
          disabled={page === 1}
          className="px-4 py-2 border rounded disabled:opacity-50"
        >
          上一頁
        </button>
        <span className="px-4 py-2">第 {page} 頁</span>
        <button
          onClick={() => setPage(p => p + 1)}
          className="px-4 py-2 border rounded"
        >
          下一頁
        </button>
      </div>
    </div>
  )
}
```

---

## 成本優化與監控

### 1. 資料庫用量監控

**檔案**: `src/app/api/maintenance/stats/route.ts`

```typescript
import { NextRequest } from 'next/server'
import { createClient } from '@/lib/supabase/server'

export async function GET(request: NextRequest) {
  try {
    const supabase = createClient()

    // 獲取各表資料量
    const { count: itemsCount } = await supabase
      .from('items')
      .select('*', { count: 'exact', head: true })

    const { count: tradesCount } = await supabase
      .from('trades')
      .select('*', { count: 'exact', head: true })

    const { count: tokensCount } = await supabase
      .from('access_tokens')
      .select('*', { count: 'exact', head: true })

    // 資料庫大小查詢（需要啟用 pg_stat 擴展）
    const { data: dbSize } = await supabase.rpc('get_database_size')

    return Response.json({
      database: {
        size: dbSize || 'N/A',
        limit: '500 MB',
        usage: dbSize ? `${((dbSize / (500 * 1024 * 1024)) * 100).toFixed(2)}%` : 'N/A'
      },
      tables: {
        items: itemsCount,
        trades: tradesCount,
        access_tokens: tokensCount
      },
      timestamp: new Date().toISOString()
    })
  } catch (error) {
    return Response.json(
      { error: '獲取統計失敗' },
      { status: 500 }
    )
  }
}
```

---

### 2. Vercel Cron Job 設定

**檔案**: `vercel.json`

```json
{
  "crons": [
    {
      "path": "/api/maintenance/cleanup",
      "schedule": "0 2 * * *"
    }
  ]
}
```

**檔案**: `src/app/api/maintenance/cleanup/route.ts`

```typescript
import { NextRequest } from 'next/server'
import { createClient } from '@/lib/supabase/server'

export async function GET(request: NextRequest) {
  // 驗證 Cron Secret
  const authHeader = request.headers.get('authorization')
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return Response.json({ error: 'Unauthorized' }, { status: 401 })
  }

  try {
    const supabase = createClient()

    // 執行清理函數
    await supabase.rpc('cleanup_old_trades')
    await supabase.rpc('cleanup_inactive_tokens')

    // 如果使用資料庫 Rate Limiting
    await supabase.rpc('cleanup_rate_limits')

    return Response.json({
      success: true,
      message: '清理完成',
      timestamp: new Date().toISOString()
    })
  } catch (error) {
    return Response.json(
      { error: '清理失敗' },
      { status: 500 }
    )
  }
}
```

---

## 安全措施

### 防護層級總結

即使是「完全信任」的系統，也需要基本防護：

#### 1. Rate Limiting（必須）
- **IP 級別**: 每分鐘 60 次通用請求
- **Token 級別**: 各操作獨立限制
- **指紋追蹤**: 防止單一用戶創建過多令牌

#### 2. 輸入驗證（必須）
```typescript
// 範例：嚴格的輸入驗證
function validateItemData(data: any) {
  if (!data.itemId || typeof data.itemId !== 'number') {
    throw new Error('物品 ID 格式錯誤')
  }

  if (data.price !== undefined) {
    if (typeof data.price !== 'number' || data.price <= 0) {
      throw new Error('價格必須是正整數')
    }
  }

  if (data.quantity !== undefined) {
    if (!Number.isInteger(data.quantity) || data.quantity <= 0) {
      throw new Error('數量必須是正整數')
    }
  }
}
```

#### 3. 業務邏輯驗證（必須）
- 不能購買自己的物品
- 物品狀態必須正確（庫存 → 上架 → 交易中）
- 使用資料庫事務確保一致性

#### 4. 資料庫安全（必須）
```sql
-- Row Level Security (RLS) 策略範例
ALTER TABLE items ENABLE ROW LEVEL SECURITY;

-- 只能修改自己的物品
CREATE POLICY "Users can update own items"
ON items FOR UPDATE
USING (character_id = current_setting('app.character_id'));

-- 所有人可以查看上架中的物品
CREATE POLICY "Anyone can view listed items"
ON items FOR SELECT
USING (status = 1 OR character_id = current_setting('app.character_id'));
```

#### 5. 監控與警報（建議）
- 記錄異常行為（如短時間大量交易）
- 定期檢查資料庫用量
- 監控 API 錯誤率

---

## 實作階段規劃

### 階段 1：基礎設施搭建（2-3 天）

**任務清單**：
- [ ] 安裝 Supabase 客戶端
  ```bash
  npm install @supabase/supabase-js
  ```
- [ ] 建立 Supabase 專案並配置環境變數
- [ ] 建立資料庫表結構（access_tokens, items, trades）
- [ ] 建立索引和清理函數
- [ ] 實作購買物品存儲過程
- [ ] 設定 Row Level Security 策略

**產出物**：
- 完整的資料庫 Schema
- 環境變數配置文件

---

### 階段 2：核心 API 開發（3-4 天）

**任務清單**：
- [ ] 實作認證系統
  - 令牌生成工具 (`src/lib/utils/token.ts`)
  - 瀏覽器指紋 (`src/lib/utils/fingerprint.ts`)
  - 認證中間件 (`src/lib/middleware/auth.ts`)
  - 認證 API (`src/app/api/auth/token/route.ts`)

- [ ] 實作物品管理 API
  - 查詢我的物品 (`GET /api/items`)
  - 新增物品 (`POST /api/items`)
  - 上架物品 (`POST /api/items/list`)
  - 下架物品 (`DELETE /api/items/[id]`)

- [ ] 實作市場 API
  - 市場列表 (`GET /api/market`)
  - 搜尋/篩選 (`GET /api/market/search`)

- [ ] 實作交易 API
  - 購買物品 (`POST /api/trades`)
  - 交易歷史 (`GET /api/trades/history`)

- [ ] 實作 Rate Limiting
  - 選擇方案（Upstash Redis 或 Edge Middleware）
  - 整合到各 API

**產出物**：
- 完整的 API 端點
- 中間件系統

---

### 階段 3：前端介面實作（3-4 天）

**任務清單**：
- [ ] 認證系統
  - TradeAuthContext (`src/contexts/TradeAuthContext.tsx`)
  - 登入表單組件

- [ ] 市場頁面
  - 市場列表組件 (`src/components/trade/MarketList.tsx`)
  - 物品卡片組件 (`src/components/trade/ItemCard.tsx`)
  - 搜尋/篩選功能

- [ ] 我的物品頁面
  - 物品列表 (`src/components/trade/MyItems.tsx`)
  - 上架表單

- [ ] 交易歷史頁面
  - 歷史記錄列表 (`src/components/trade/TradeHistory.tsx`)

- [ ] UI/UX 優化
  - 載入狀態
  - 錯誤處理
  - 響應式設計

**產出物**：
- 完整的前端介面
- 用戶體驗流程

---

### 階段 4：優化與測試（2-3 天）

**任務清單**：
- [ ] 資料庫優化
  - 確認索引有效性
  - 查詢效能測試
  - 分析慢查詢

- [ ] API 性能測試
  - 壓力測試（模擬 1000+ 並發）
  - Rate Limiting 驗證
  - 錯誤處理完整性

- [ ] 監控系統
  - 實作用量統計 API
  - 前端監控儀表板（可選）

- [ ] 定期清理
  - 驗證清理函數
  - 設置 Vercel Cron Job

**產出物**：
- 性能測試報告
- 監控系統

---

### 階段 5：部署與監控（1 天）

**任務清單**：
- [ ] Supabase 生產環境配置
  - 資料庫備份策略
  - RLS 策略驗證

- [ ] Vercel 部署
  - 環境變數設定
  - Cron Job 配置
  - 域名綁定（可選）

- [ ] 監控設置
  - Supabase 用量監控
  - Vercel Analytics
  - 錯誤追蹤（可選：Sentry）

**產出物**：
- 生產環境系統
- 監控儀表板

---

## 免費額度評估

### Supabase 免費版

| 項目 | 免費額度 | 預估使用 | 評估 |
|------|---------|---------|------|
| 資料庫空間 | 500 MB | ~50-100 MB（50萬筆交易） | ✅ 充足 |
| 月活躍用戶 | 50,000 | ~1,000-2,000 | ✅ 充足 |
| 資料庫請求 | 無限制 | ~100萬次/月 | ✅ 無限制 |
| 儲存空間 | 1 GB | 不需要檔案儲存 | ✅ 不使用 |

**空間估算**：
```
單筆交易記錄 ~100 bytes
500 MB = 5,000,000 筆交易記錄
實際可能因索引佔用：~500,000 筆
```

---

### Vercel 免費版

| 項目 | 免費額度 | 預估使用 | 評估 |
|------|---------|---------|------|
| 流量 | 100 GB/月 | ~10-20 GB/月 | ✅ 充足 |
| 函數執行時間 | 100 小時/月 | ~5-10 小時/月 | ✅ 充足 |
| 建置次數 | 6,000 分鐘/月 | ~50 分鐘/月 | ✅ 充足 |
| Cron Jobs | 1 個 | 1 個（清理任務） | ✅ 足夠 |

---

### Upstash Redis 免費版

| 項目 | 免費額度 | 預估使用 | 評估 |
|------|---------|---------|------|
| 命令數 | 10,000/天 | ~5,000/天 | ✅ 充足 |
| 儲存空間 | 256 MB | ~1 MB | ✅ 充足 |
| 並發連線 | 100 | ~10-20 | ✅ 充足 |

**命令數估算**：
```
假設 1000 人/月，每人平均 10 次操作
= ~330 次操作/天
每次操作 Rate Limit 檢查：4 個 Redis 命令
= ~1,320 命令/天
```

---

### 成本監控建議

#### 每週檢查項目
```bash
# 1. 資料庫大小
SELECT pg_database_size('postgres') / 1024 / 1024 AS size_mb;

# 2. 各表資料量
SELECT
  'items' AS table_name, COUNT(*) AS rows FROM items
UNION ALL
SELECT 'trades', COUNT(*) FROM trades
UNION ALL
SELECT 'access_tokens', COUNT(*) FROM access_tokens;

# 3. 未清理的舊資料
SELECT COUNT(*) FROM trades WHERE traded_at < NOW() - INTERVAL '30 days';
```

#### 警報閾值
- 資料庫使用 > 400 MB (80%) → 檢查清理策略
- 日請求量 > 100,000 → 檢查是否異常流量
- Redis 命令 > 8,000/天 (80%) → 優化 Rate Limit 策略

---

## 附錄

### A. 環境變數範例

```env
# Supabase
NEXT_PUBLIC_SUPABASE_URL=https://xxx.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
SUPABASE_SERVICE_ROLE_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

# Upstash Redis (可選)
UPSTASH_REDIS_REST_URL=https://xxx.upstash.io
UPSTASH_REDIS_REST_TOKEN=AXX...

# Vercel Cron Secret
CRON_SECRET=your-random-secret-here
```

---

### B. 資料庫完整 Schema

詳見「資料庫設計」章節的 SQL 腳本。

---

### C. 參考資源

- [Supabase 文檔](https://supabase.com/docs)
- [Next.js App Router](https://nextjs.org/docs/app)
- [Upstash Redis](https://docs.upstash.com/redis)
- [Vercel Cron Jobs](https://vercel.com/docs/cron-jobs)

---

**文檔版本**: v1.0
**最後更新**: 2025-10-25
**維護者**: Claude Code
