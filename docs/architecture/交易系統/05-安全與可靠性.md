# å®‰å…¨èˆ‡å¯é æ€§è¨­è¨ˆ

> **æœ€å¾Œæ›´æ–°**ï¼š2025-10-26

---

## ğŸ“š å°èˆª

[â† ä¸Šä¸€ç¯‡:Discordæ•´åˆ](./04-Discordæ•´åˆ.md) | [ğŸ  è¿”å›ç›®éŒ„](./README.md) | [ä¸‹ä¸€ç¯‡:æ•ˆèƒ½åˆ†æèˆ‡æˆæœ¬ â†’](./06-æ•ˆèƒ½åˆ†æèˆ‡æˆæœ¬.md)

---

## å®‰å…¨æ€§è¨­è¨ˆ

### 1. Discord OAuth å®‰å…¨

- **State åƒæ•¸é©—è­‰**ï¼šé˜²æ­¢ CSRF æ”»æ“Š
- **Token åŠ å¯†å­˜å„²**ï¼šAES-256-GCM åŠ å¯†
- **Session Cookie å®‰å…¨**ï¼šHttpOnly + Secure + SameSite

### 2. API å®‰å…¨

- **Rate Limiting**ï¼šé˜²æ­¢æ¿«ç”¨ï¼ˆ10K è«‹æ±‚/å¤©ï¼‰
- **Bot Detection**ï¼šUser-Agent éæ¿¾
- **IP é…é¡**ï¼šé˜²æ­¢å¤šå¸³è™Ÿç¹é

### 3. è³‡æ–™åº«å®‰å…¨

- **Row Level Security**ï¼šSupabase RLS Policies
- **è¼¸å…¥é©—è­‰**ï¼šCHECK ç´„æŸ
- **SQL Injection é˜²è­·**ï¼šåƒæ•¸åŒ–æŸ¥è©¢

### 4. å®‰å…¨æ€§é¢¨éšªèˆ‡é˜²è­·è©³è§£

#### Token æ´©æ¼é¢¨éšªèˆ‡é˜²è­·

**é¢¨éšªå ´æ™¯**ï¼š
- ğŸ”´ **XSS æ”»æ“Šç«Šå– Cookie**ï¼šé›–ç„¶ä½¿ç”¨ HttpOnlyï¼Œä½†ä»éœ€é˜²ç¯„ XSS
- ğŸ”´ **CSRF æ”»æ“Š**ï¼šå½é€ è«‹æ±‚åˆ©ç”¨å·²ç™»å…¥çš„ session
- ğŸ”´ **ä¸­é–“äººæ”»æ“Š**ï¼šHTTP é€£æ¥è¢«ç«Šè½

**é˜²è­·æªæ–½**ï¼š

```typescript
// src/lib/security/xss-prevention.ts
import DOMPurify from 'isomorphic-dompurify'

// 1. è¼¸å…¥æ¸…ç†ï¼ˆé˜²æ­¢ XSSï¼‰
export function sanitizeUserInput(input: string): string {
  return DOMPurify.sanitize(input, {
    ALLOWED_TAGS: [], // ä¸å…è¨±ä»»ä½• HTML æ¨™ç±¤
    ALLOWED_ATTR: []
  })
}

// 2. è¼¸å‡ºç·¨ç¢¼
export function encodeHTML(str: string): string {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;')
}

// ä½¿ç”¨ç¯„ä¾‹
export async function createListing(data: ListingInput): Promise<Listing> {
  const sanitized = {
    ...data,
    item_name: sanitizeUserInput(data.item_name),
    description: sanitizeUserInput(data.description),
    discord_contact: sanitizeUserInput(data.discord_contact)
  }

  return await db.listings.create(sanitized)
}
```

#### CSRF é˜²è­·å®Œæ•´æ–¹æ¡ˆ

**State åƒæ•¸ç”Ÿæˆèˆ‡é©—è­‰**ï¼š

```typescript
// src/lib/security/csrf.ts
import crypto from 'crypto'
import { redis } from '@/lib/redis'

export function generateStateToken(): string {
  return crypto.randomBytes(32).toString('hex')
}

export async function storeStateToken(state: string): Promise<void> {
  // å„²å­˜åˆ° Redisï¼Œ5 åˆ†é˜éæœŸ
  await redis.setex(`oauth:state:${state}`, 300, '1')
}

export async function validateStateToken(state: string): Promise<boolean> {
  const exists = await redis.get(`oauth:state:${state}`)
  if (exists) {
    // é©—è­‰å¾Œç«‹å³åˆªé™¤ï¼ˆä¸€æ¬¡æ€§ä½¿ç”¨ï¼‰
    await redis.del(`oauth:state:${state}`)
    return true
  }
  return false
}

// Discord OAuth å•Ÿå‹•
export async function GET(request: NextRequest) {
  const state = generateStateToken()
  await storeStateToken(state)

  const params = new URLSearchParams({
    client_id: process.env.DISCORD_CLIENT_ID!,
    redirect_uri: process.env.DISCORD_REDIRECT_URI!,
    response_type: 'code',
    scope: 'identify',
    state
  })

  return NextResponse.redirect(`https://discord.com/api/oauth2/authorize?${params}`)
}

// Discord OAuth å›èª¿
export async function GET(request: NextRequest) {
  const { searchParams } = request.nextUrl
  const state = searchParams.get('state')
  const code = searchParams.get('code')

  if (!state || !code) {
    return new NextResponse('Missing parameters', { status: 400 })
  }

  // é©—è­‰ state token
  const isValid = await validateStateToken(state)
  if (!isValid) {
    return new NextResponse('Invalid state token', { status: 403 })
  }

  // ç¹¼çºŒ OAuth æµç¨‹...
}
```

#### SQL Injection é˜²è­·ç¯„ä¾‹

**éŒ¯èª¤åšæ³•**ï¼ˆæ˜“å—æ”»æ“Šï¼‰ï¼š

```typescript
// âŒ éŒ¯èª¤ï¼šå­—ä¸²æ‹¼æ¥æŸ¥è©¢
async function getUser(username: string) {
  const query = `SELECT * FROM users WHERE username = '${username}'`
  // è‹¥ username = "admin' OR '1'='1"ï¼Œå‰‡æœƒè¿”å›æ‰€æœ‰ç”¨æˆ¶ï¼
  return await db.query(query)
}
```

**æ­£ç¢ºåšæ³•**ï¼ˆä½¿ç”¨åƒæ•¸åŒ–æŸ¥è©¢ï¼‰ï¼š

```typescript
// âœ… æ­£ç¢ºï¼šSupabase è‡ªå‹•åƒæ•¸åŒ–
async function getUser(username: string) {
  const { data } = await supabase
    .from('users')
    .select('*')
    .eq('username', username) // è‡ªå‹•åƒæ•¸åŒ–ï¼Œé˜²æ­¢ SQL Injection
    .single()

  return data
}

// âœ… æ­£ç¢ºï¼šä½¿ç”¨åŸå§‹ SQL æ™‚çš„åƒæ•¸åŒ–
async function getUserWithRawSQL(username: string) {
  const { data } = await supabase.rpc('get_user_by_username', {
    p_username: username // åƒæ•¸å‚³éï¼Œè€Œéå­—ä¸²æ‹¼æ¥
  })

  return data
}
```

**è³‡æ–™åº«å‡½æ•¸å®šç¾©**ï¼ˆSupabaseï¼‰ï¼š

```sql
-- å®‰å…¨çš„è³‡æ–™åº«å‡½æ•¸ï¼ˆåƒæ•¸åŒ–ï¼‰
CREATE OR REPLACE FUNCTION get_user_by_username(p_username TEXT)
RETURNS TABLE (
  id UUID,
  discord_id TEXT,
  discord_username TEXT
) AS $$
BEGIN
  RETURN QUERY
  SELECT u.id, u.discord_id, u.discord_username
  FROM users u
  WHERE u.discord_username = p_username; -- åƒæ•¸åŒ–ï¼Œå®‰å…¨
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

#### Content Security Policy (CSP)

```typescript
// src/middleware.ts
export function middleware(request: NextRequest) {
  const response = NextResponse.next()

  // è¨­ç½® CSP header
  response.headers.set(
    'Content-Security-Policy',
    [
      "default-src 'self'",
      "script-src 'self' 'unsafe-inline' 'unsafe-eval'", // Next.js éœ€è¦
      "style-src 'self' 'unsafe-inline'",
      "img-src 'self' data: https:",
      "font-src 'self' data:",
      "connect-src 'self' https://discord.com https://*.supabase.co",
      "frame-ancestors 'none'"
    ].join('; ')
  )

  // å…¶ä»–å®‰å…¨ headers
  response.headers.set('X-Frame-Options', 'DENY')
  response.headers.set('X-Content-Type-Options', 'nosniff')
  response.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin')
  response.headers.set('Permissions-Policy', 'geolocation=(), microphone=(), camera=()')

  return response
}
```

---

## å¯é æ€§è¨­è¨ˆ

### Session ç®¡ç†ç­–ç•¥

#### Session ç”Ÿå‘½é€±æœŸ

**Session å„²å­˜æ–¹å¼**ï¼š
- ä½¿ç”¨ **HTTP-only Cookie** å„²å­˜åŠ å¯†çš„ JWT token
- Token åŒ…å«ï¼šuser_idã€discord_idã€éæœŸæ™‚é–“ã€ç°½ç™¼æ™‚é–“

**Session æœ‰æ•ˆæœŸ**ï¼š
```typescript
// src/lib/auth/session.ts
const SESSION_CONFIG = {
  ACCESS_TOKEN_EXPIRES_IN: 7 * 24 * 60 * 60, // 7 å¤©
  REFRESH_TOKEN_EXPIRES_IN: 30 * 24 * 60 * 60, // 30 å¤©
  COOKIE_MAX_AGE: 30 * 24 * 60 * 60, // 30 å¤©
  REMEMBER_ME_EXPIRES_IN: 90 * 24 * 60 * 60, // 90 å¤©ï¼ˆå¯é¸åŠŸèƒ½ï¼‰
}

interface SessionToken {
  user_id: string
  discord_id: string
  discord_username: string
  issued_at: number
  expires_at: number
  refresh_token?: string
}

export function createSessionToken(user: User, rememberMe: boolean = false): string {
  const expiresIn = rememberMe
    ? SESSION_CONFIG.REMEMBER_ME_EXPIRES_IN
    : SESSION_CONFIG.ACCESS_TOKEN_EXPIRES_IN

  const payload: SessionToken = {
    user_id: user.id,
    discord_id: user.discord_id,
    discord_username: user.discord_username,
    issued_at: Date.now(),
    expires_at: Date.now() + expiresIn * 1000,
  }

  return jwt.sign(payload, process.env.JWT_SECRET!)
}
```

#### Session é©—è­‰æµç¨‹

```typescript
// src/lib/middleware/session-validator.ts
export async function validateSession(
  request: NextRequest
): Promise<{ valid: boolean; user?: User; shouldRefresh?: boolean }> {
  const token = request.cookies.get('session')?.value

  if (!token) {
    return { valid: false }
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as SessionToken

    // 1. æª¢æŸ¥éæœŸæ™‚é–“
    if (Date.now() > decoded.expires_at) {
      return { valid: false, shouldRefresh: true }
    }

    // 2. æª¢æŸ¥æ˜¯å¦éœ€è¦åˆ·æ–°ï¼ˆå‰©é¤˜æ™‚é–“ < 25%ï¼‰
    const timeLeft = decoded.expires_at - Date.now()
    const totalTime = decoded.expires_at - decoded.issued_at
    const shouldRefresh = timeLeft < totalTime * 0.25

    // 3. å¾è³‡æ–™åº«é©—è­‰ç”¨æˆ¶æ˜¯å¦ä»ç„¶å­˜åœ¨
    const user = await supabase
      .from('users')
      .select('*')
      .eq('id', decoded.user_id)
      .single()

    if (!user.data) {
      return { valid: false }
    }

    return {
      valid: true,
      user: user.data,
      shouldRefresh
    }
  } catch (error) {
    return { valid: false }
  }
}
```

### Token è‡ªå‹•åˆ·æ–°æ©Ÿåˆ¶

#### åˆ·æ–°ç­–ç•¥

**è‡ªå‹•åˆ·æ–°æ™‚æ©Ÿ**ï¼š
- Token å‰©é¤˜æœ‰æ•ˆæœŸ < 25%ï¼ˆä¾‹å¦‚ï¼š7 å¤© tokenï¼Œå‰©é¤˜ < 1.75 å¤©ï¼‰
- ç”¨æˆ¶æ´»èºæ™‚æ‰åˆ·æ–°ï¼ˆé¿å…ç„¡æ•ˆåˆ·æ–°ï¼‰

**å¯¦ä½œç¯„ä¾‹**ï¼š

```typescript
// src/lib/auth/token-refresh.ts
export async function refreshSessionIfNeeded(
  request: NextRequest,
  response: NextResponse,
  user: User,
  shouldRefresh: boolean
): Promise<NextResponse> {
  if (!shouldRefresh) {
    return response
  }

  // ç”Ÿæˆæ–° token
  const newToken = createSessionToken(user)

  // æ›´æ–° cookie
  response.cookies.set('session', newToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: SESSION_CONFIG.COOKIE_MAX_AGE,
    path: '/',
  })

  // è¨˜éŒ„åˆ·æ–°äº‹ä»¶ï¼ˆå¯é¸ï¼Œç”¨æ–¼ç›£æ§ï¼‰
  await logTokenRefresh(user.id)

  return response
}

async function logTokenRefresh(userId: string): Promise<void> {
  // è¨˜éŒ„åˆ°è³‡æ–™åº«æˆ–æ—¥èªŒç³»çµ±
  console.log(`[Token Refresh] User ${userId} token refreshed`)
}
```

#### å®¢æˆ¶ç«¯åˆ·æ–°é‚è¼¯

```typescript
// src/lib/hooks/useSession.ts
import { useEffect } from 'react'
import { useRouter } from 'next/navigation'

export function useSession() {
  const router = useRouter()

  useEffect(() => {
    // æ¯ 5 åˆ†é˜æª¢æŸ¥ä¸€æ¬¡ session ç‹€æ…‹
    const interval = setInterval(async () => {
      const response = await fetch('/api/auth/session', {
        method: 'GET',
        credentials: 'include',
      })

      if (!response.ok) {
        // Session éæœŸï¼Œè§¸ç™¼ç™»å…¥ Modalï¼ˆè¦‹ DDR-003ï¼‰
        const event = new CustomEvent('show-login-modal')
        window.dispatchEvent(event)
      }

      // å¦‚æœ response åŒ…å«æ–°çš„ Set-Cookie headerï¼Œç€è¦½å™¨æœƒè‡ªå‹•æ›´æ–°
    }, 5 * 60 * 1000) // 5 åˆ†é˜

    return () => clearInterval(interval)
  }, [router])
}
```

### Token æ’¤éŠ·æ©Ÿåˆ¶

#### æ’¤éŠ·å ´æ™¯

1. **ç”¨æˆ¶ä¸»å‹•ç™»å‡º**
2. **å¯†ç¢¼ä¿®æ”¹**ï¼ˆå¦‚æœæœªä¾†æ”¯æ´å¯†ç¢¼ç™»å…¥ï¼‰
3. **å¸³è™Ÿå®‰å…¨äº‹ä»¶**ï¼ˆå¦‚ï¼šå¯ç–‘æ´»å‹•ï¼‰
4. **ç®¡ç†å“¡æ“ä½œ**ï¼ˆå¦‚ï¼šå°ç¦ç”¨æˆ¶ï¼‰

#### Token é»‘åå–®å¯¦ä½œ

**ä½¿ç”¨ Redis å„²å­˜è¢«æ’¤éŠ·çš„ Token**ï¼š

```typescript
// src/lib/auth/token-revocation.ts
import { redis } from '@/lib/redis'

export async function revokeToken(token: string): Promise<void> {
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as SessionToken

    // è¨ˆç®—å‰©é¤˜æœ‰æ•ˆæ™‚é–“
    const ttl = Math.max(0, Math.floor((decoded.expires_at - Date.now()) / 1000))

    // åŠ å…¥é»‘åå–®ï¼ˆåªéœ€ä¿ç•™åˆ°åŸæœ¬çš„éæœŸæ™‚é–“ï¼‰
    await redis.setex(`revoked:${token}`, ttl, '1')
  } catch (error) {
    // Token ç„¡æ•ˆæˆ–å·²éæœŸï¼Œç„¡éœ€è™•ç†
  }
}

export async function isTokenRevoked(token: string): Promise<boolean> {
  const result = await redis.get(`revoked:${token}`)
  return result === '1'
}

// åœ¨ session é©—è­‰æ™‚æª¢æŸ¥
export async function validateSessionWithRevocation(
  request: NextRequest
): Promise<{ valid: boolean; user?: User }> {
  const token = request.cookies.get('session')?.value

  if (!token) {
    return { valid: false }
  }

  // 1. æª¢æŸ¥æ˜¯å¦è¢«æ’¤éŠ·
  if (await isTokenRevoked(token)) {
    return { valid: false }
  }

  // 2. åŸ·è¡Œæ­£å¸¸é©—è­‰
  const result = await validateSession(request)
  return result
}
```

#### å…¨å±€ç™»å‡ºåŠŸèƒ½

```typescript
// src/lib/auth/global-logout.ts
export async function revokeAllUserSessions(userId: string): Promise<void> {
  // 1. æ¨™è¨˜ç”¨æˆ¶éœ€è¦é‡æ–°ç™»å…¥
  await supabase
    .from('users')
    .update({ force_relogin: true, force_relogin_at: new Date() })
    .eq('id', userId)

  // 2. åœ¨ session é©—è­‰æ™‚æª¢æŸ¥æ­¤æ¨™è¨˜
}

// ä¿®æ”¹ validateSession å‡½æ•¸
export async function validateSession(
  request: NextRequest
): Promise<{ valid: boolean; user?: User }> {
  // ... åŸæœ‰é‚è¼¯ ...

  // æª¢æŸ¥æ˜¯å¦éœ€è¦å¼·åˆ¶é‡æ–°ç™»å…¥
  if (user.data.force_relogin) {
    const tokenIssuedAt = decoded.issued_at
    const forceReloginAt = new Date(user.data.force_relogin_at).getTime()

    // Token ç°½ç™¼æ™‚é–“æ—©æ–¼å¼·åˆ¶ç™»å‡ºæ™‚é–“ â†’ ç„¡æ•ˆ
    if (tokenIssuedAt < forceReloginAt) {
      return { valid: false }
    }
  }

  return { valid: true, user: user.data }
}
```

### å¤šè£ç½®åŒæ­¥

#### åŒæ­¥ç­–ç•¥

**è¨­è¨ˆç›®æ¨™**ï¼š
- å…è¨±åŒä¸€ç”¨æˆ¶åœ¨å¤šå€‹è£ç½®åŒæ™‚ç™»å…¥
- æ¯å€‹è£ç½®ç¨ç«‹ session
- æä¾›æŸ¥çœ‹å’Œç®¡ç†æ‰€æœ‰ session çš„åŠŸèƒ½

#### Session è£ç½®è¿½è¹¤

```sql
-- Session è£ç½®è¡¨
CREATE TABLE user_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

  -- è£ç½®è³‡è¨Š
  device_name TEXT,  -- å¾ User-Agent è§£æ
  device_type TEXT,  -- 'mobile' | 'desktop' | 'tablet'
  browser TEXT,      -- 'Chrome' | 'Firefox' | 'Safari'
  os TEXT,           -- 'Windows' | 'macOS' | 'Linux' | 'iOS' | 'Android'

  -- Session è³‡è¨Š
  session_token_hash TEXT NOT NULL UNIQUE,  -- Token çš„ SHA-256 hash
  ip_address INET,
  last_active_at TIMESTAMPTZ DEFAULT NOW(),
  expires_at TIMESTAMPTZ NOT NULL,

  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_user_sessions_user ON user_sessions(user_id);
CREATE INDEX idx_user_sessions_expires ON user_sessions(expires_at);
```

#### Session ç®¡ç† API

```typescript
// src/app/api/auth/sessions/route.ts
export async function GET(request: NextRequest) {
  const user = await getCurrentUser(request)
  if (!user) {
    return new NextResponse('Unauthorized', { status: 401 })
  }

  // ç²å–ç”¨æˆ¶æ‰€æœ‰æ´»èº session
  const sessions = await supabase
    .from('user_sessions')
    .select('*')
    .eq('user_id', user.id)
    .gt('expires_at', new Date().toISOString())
    .order('last_active_at', { ascending: false })

  return NextResponse.json(sessions.data)
}

export async function DELETE(request: NextRequest) {
  const user = await getCurrentUser(request)
  if (!user) {
    return new NextResponse('Unauthorized', { status: 401 })
  }

  const { sessionId } = await request.json()

  // æ’¤éŠ·ç‰¹å®š session
  const session = await supabase
    .from('user_sessions')
    .select('session_token_hash')
    .eq('id', sessionId)
    .eq('user_id', user.id)
    .single()

  if (session.data) {
    // åŠ å…¥é»‘åå–®
    await revokeToken(session.data.session_token_hash)

    // åˆªé™¤è¨˜éŒ„
    await supabase
      .from('user_sessions')
      .delete()
      .eq('id', sessionId)
  }

  return NextResponse.json({ success: true })
}
```

#### è‡ªå‹•æ¸…ç†éæœŸ Session

```typescript
// src/lib/cron/cleanup-sessions.ts
export async function cleanupExpiredSessions(): Promise<void> {
  // åˆªé™¤å·²éæœŸçš„ session è¨˜éŒ„
  const { count } = await supabase
    .from('user_sessions')
    .delete()
    .lt('expires_at', new Date().toISOString())

  console.log(`[Session Cleanup] Removed ${count} expired sessions`)
}

// ä½¿ç”¨ Vercel Cron Jobs æ¯å¤©åŸ·è¡Œä¸€æ¬¡
// vercel.json:
// {
//   "crons": [{
//     "path": "/api/cron/cleanup-sessions",
//     "schedule": "0 0 * * *"
//   }]
// }
```

---


---

## ğŸ“š å°èˆª

[â† ä¸Šä¸€ç¯‡:Discordæ•´åˆ](./04-Discordæ•´åˆ.md) | [ğŸ  è¿”å›ç›®éŒ„](./README.md) | [ä¸‹ä¸€ç¯‡:æ•ˆèƒ½åˆ†æèˆ‡æˆæœ¬ â†’](./06-æ•ˆèƒ½åˆ†æèˆ‡æˆæœ¬.md)
