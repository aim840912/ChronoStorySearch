/**
 * Token åŠ å¯†å·¥å…·å–®å…ƒæ¸¬è©¦
 */

import { encryptToken, decryptToken, isTokenEncrypted } from '../token-encryption'

// è¨­å®šæ¸¬è©¦ç”¨çš„åŠ å¯†å¯†é‘°ï¼ˆ256-bit = 64 hex charactersï¼‰
const TEST_ENCRYPTION_KEY = 'a'.repeat(64)

describe('Token Encryption', () => {
  beforeAll(() => {
    // è¨­å®šæ¸¬è©¦ç’°å¢ƒè®Šæ•¸
    process.env.TOKEN_ENCRYPTION_KEY = TEST_ENCRYPTION_KEY
  })

  afterAll(() => {
    // æ¸…ç†ç’°å¢ƒè®Šæ•¸
    delete process.env.TOKEN_ENCRYPTION_KEY
  })

  describe('encryptToken', () => {
    it('should encrypt a token successfully', async () => {
      const originalToken = 'test_access_token_12345'
      const encrypted = await encryptToken(originalToken)

      // åŠ å¯†å¾Œæ‡‰è©²æ˜¯ Base64 å­—ä¸²
      expect(typeof encrypted).toBe('string')
      expect(encrypted.length).toBeGreaterThan(0)

      // åŠ å¯†å¾Œæ‡‰è©²èˆ‡åŸæ–‡ä¸åŒ
      expect(encrypted).not.toBe(originalToken)

      // æ‡‰è©²æ˜¯æœ‰æ•ˆçš„ Base64
      expect(() => Buffer.from(encrypted, 'base64')).not.toThrow()
    })

    it('should use different nonce each time (same input â†’ different output)', async () => {
      const token = 'same_token_value'

      const encrypted1 = await encryptToken(token)
      const encrypted2 = await encryptToken(token)

      // ç›¸åŒçš„æ˜æ–‡ï¼Œæ¯æ¬¡åŠ å¯†çµæœæ‡‰è©²ä¸åŒï¼ˆå› ç‚º nonce ä¸åŒï¼‰
      expect(encrypted1).not.toBe(encrypted2)
    })

    it('should handle empty string', async () => {
      const encrypted = await encryptToken('')
      expect(encrypted).toBeDefined()
      expect(encrypted.length).toBeGreaterThan(0)
    })

    it('should handle long tokens', async () => {
      const longToken = 'x'.repeat(1000)
      const encrypted = await encryptToken(longToken)

      expect(encrypted).toBeDefined()
      expect(encrypted.length).toBeGreaterThan(longToken.length)
    })

    it('should handle special characters', async () => {
      const tokenWithSpecialChars = 'token!@#$%^&*()_+-={}[]|\\:";\'<>?,./'
      const encrypted = await encryptToken(tokenWithSpecialChars)

      expect(encrypted).toBeDefined()
      expect(() => Buffer.from(encrypted, 'base64')).not.toThrow()
    })

    it('should handle Unicode characters', async () => {
      const unicodeToken = 'token_with_emoji_ğŸ”_and_ä¸­æ–‡'
      const encrypted = await encryptToken(unicodeToken)

      expect(encrypted).toBeDefined()
    })
  })

  describe('decryptToken', () => {
    it('should decrypt an encrypted token correctly', async () => {
      const originalToken = 'test_access_token_12345'

      const encrypted = await encryptToken(originalToken)
      const decrypted = await decryptToken(encrypted)

      expect(decrypted).toBe(originalToken)
    })

    it('should handle empty string encryption/decryption', async () => {
      const originalToken = ''

      const encrypted = await encryptToken(originalToken)
      const decrypted = await decryptToken(encrypted)

      expect(decrypted).toBe(originalToken)
    })

    it('should handle long tokens encryption/decryption', async () => {
      const originalToken = 'y'.repeat(1000)

      const encrypted = await encryptToken(originalToken)
      const decrypted = await decryptToken(encrypted)

      expect(decrypted).toBe(originalToken)
    })

    it('should handle special characters encryption/decryption', async () => {
      const originalToken = 'token!@#$%^&*()_+-={}[]|\\:";\'<>?,./'

      const encrypted = await encryptToken(originalToken)
      const decrypted = await decryptToken(encrypted)

      expect(decrypted).toBe(originalToken)
    })

    it('should handle Unicode encryption/decryption', async () => {
      const originalToken = 'token_with_emoji_ğŸ”_and_ä¸­æ–‡'

      const encrypted = await encryptToken(originalToken)
      const decrypted = await decryptToken(encrypted)

      expect(decrypted).toBe(originalToken)
    })

    it('should throw error on invalid Base64', async () => {
      const invalidBase64 = 'not_valid_base64!@#$'

      await expect(decryptToken(invalidBase64)).rejects.toThrow()
    })

    it('should throw error on tampered ciphertext', async () => {
      const originalToken = 'test_token'
      const encrypted = await encryptToken(originalToken)

      // ç¯¡æ”¹æœ€å¾Œ 4 å€‹å­—å…ƒ
      const tampered = encrypted.slice(0, -4) + 'XXXX'

      await expect(decryptToken(tampered)).rejects.toThrow('Token decryption failed')
    })

    it('should throw error on truncated ciphertext', async () => {
      const originalToken = 'test_token'
      const encrypted = await encryptToken(originalToken)

      // æˆªæ–·ï¼ˆåªå–å‰ä¸€åŠï¼‰
      const truncated = encrypted.slice(0, encrypted.length / 2)

      await expect(decryptToken(truncated)).rejects.toThrow()
    })

    it('should throw error if ciphertext is too short', async () => {
      // Base64 ç·¨ç¢¼çš„çŸ­å­—ä¸²ï¼ˆ< 24 bytes after decodeï¼‰
      const tooShort = Buffer.from('short').toString('base64')

      await expect(decryptToken(tooShort)).rejects.toThrow('Invalid encrypted token: too short')
    })

    it('should throw error if encryption key is missing', async () => {
      // æš«æ™‚ç§»é™¤å¯†é‘°
      delete process.env.TOKEN_ENCRYPTION_KEY

      await expect(encryptToken('test')).rejects.toThrow(
        'TOKEN_ENCRYPTION_KEY is not configured in environment variables'
      )

      // æ¢å¾©å¯†é‘°
      process.env.TOKEN_ENCRYPTION_KEY = TEST_ENCRYPTION_KEY
    })

    it('should throw error if encryption key is invalid length', async () => {
      // è¨­å®šéŒ¯èª¤é•·åº¦çš„å¯†é‘°
      process.env.TOKEN_ENCRYPTION_KEY = 'too_short'

      await expect(encryptToken('test')).rejects.toThrow(
        'TOKEN_ENCRYPTION_KEY must be a 64-character hex string (256-bit)'
      )

      // æ¢å¾©æ­£ç¢ºå¯†é‘°
      process.env.TOKEN_ENCRYPTION_KEY = TEST_ENCRYPTION_KEY
    })
  })

  describe('isTokenEncrypted', () => {
    it('should return true for encrypted tokens', async () => {
      const originalToken = 'test_token_value'
      const encrypted = await encryptToken(originalToken)

      expect(isTokenEncrypted(encrypted)).toBe(true)
    })

    it('should return false for plaintext tokens', () => {
      const plaintextTokens = [
        'ya29.a0AfH6SMBx...',  // Google OAuth token
        'Bearer eyJhbGciOiJIUzI1NiIs...',  // JWT
        'ghp_abc123...',  // GitHub token
        'short',
      ]

      plaintextTokens.forEach((token) => {
        expect(isTokenEncrypted(token)).toBe(false)
      })
    })

    it('should return false for non-Base64 strings', () => {
      const nonBase64Strings = [
        'not!valid@base64',
        'hello world',
        'token with spaces',
      ]

      nonBase64Strings.forEach((str) => {
        expect(isTokenEncrypted(str)).toBe(false)
      })
    })

    it('should return false for empty string', () => {
      expect(isTokenEncrypted('')).toBe(false)
    })

    it('should return false for short Base64 strings', () => {
      // é›–ç„¶æ˜¯æœ‰æ•ˆçš„ Base64ï¼Œä½†å¤ªçŸ­ï¼ˆ< 50 charactersï¼‰
      const shortBase64 = Buffer.from('short').toString('base64')

      expect(isTokenEncrypted(shortBase64)).toBe(false)
    })
  })

  describe('Round-trip encryption/decryption', () => {
    it('should handle multiple round-trips correctly', async () => {
      let token = 'original_token'

      for (let i = 0; i < 5; i++) {
        const encrypted = await encryptToken(token)
        const decrypted = await decryptToken(encrypted)

        expect(decrypted).toBe(token)

        // ä¸‹ä¸€è¼ªä½¿ç”¨åŠ å¯†å¾Œçš„å­—ä¸²ï¼ˆæ¸¬è©¦èƒ½å¦è™•ç†ä»»æ„å­—ä¸²ï¼‰
        token = encrypted
      }
    })

    it('should maintain data integrity across encrypt/decrypt', async () => {
      const testCases = [
        'simple_token',
        '',
        ' ',
        'token with spaces',
        'token\nwith\nnewlines',
        'token\twith\ttabs',
        'token_ğŸ”_emoji',
        'ä¸­æ–‡å­—ç¬¦',
        '{"json": "token"}',
        'a'.repeat(10000),  // é•·å­—ä¸²
      ]

      for (const testCase of testCases) {
        const encrypted = await encryptToken(testCase)
        const decrypted = await decryptToken(encrypted)

        expect(decrypted).toBe(testCase)
      }
    })
  })
})
